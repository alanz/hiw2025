<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>An alternative to CPP (HIW 2025)</title>
<meta name="author" content="Alan Zimmerman"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/white_contrast_compact_verbatim_headers.css" id="theme"/>

<link rel="stylesheet" href="./local.css"/>

<link rel="stylesheet" href="./reveal.js/plugin/toc-progress/toc-progress.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<section id="slide-orgf8aeea8">
<h2 id="orgf8aeea8">An alternative to CPP</h2>
<p>
Alan Zimmerman
</p>

<p>
<a href="https://social.coop/@alanz"><code>@alanz@social.coop</code></a>
</p>

<p>
Haskell Implementors' Workshop,
</p>

<p>
ZuriHac, 2025-06-06
</p>

<aside class="notes">
<p>
Hi, Alan Zimmerman, I look after ghc-exactprint.
</p>

<p>
And today I want to talk about CPP, which has pained me ever since I
started working on Haskell refactoring tools over ten years ago.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgf366ed4">
<h2 id="orgf366ed4">CPP</h2>
<ul>
<li>In use from the beginning, at least GHC 2.0</li>
<li>Used mainly to manage differences between versions</li>
<li>Is outside the language of Haskell</li>

</ul>

<aside class="notes">
<p>
The C preprocessor. Or C++ preprocessor.
</p>

<p>
My 5 min research shows it was in GHC 2 already, from 1997.
<a href="https://downloads.haskell.org/~ghc/old_docs/2.10/users_guide/user_33.html#IDX109">https://downloads.haskell.org/~ghc/old_docs/2.10/users_guide/user_33.html#IDX109</a>
The docs are for 2.10, but the changelog back to 2.0 does not mention it being added.
</p>

<p>
Because it is outside the language, it can manage changes between
versions without itself being tripped up by syntax.
</p>

<p>
It runs using the generalised GHC capability to run a preprocessor
programme over the source
</p>

<p>
But is in a privileged position because it is deeply embedded in GHC
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org160dac0">
<h2 id="org160dac0">CPP Support</h2>
<ul>
<li>"Simply" an extension, which triggers all the machinery
<ul>
<li>See [Preprocessing invocations]</li>

</ul></li>
<li>GHC provides predefined macros describing the environment</li>
<li>Even so, it is invoked as an external programme</li>

</ul>

<aside class="notes">
<ul>
<li>Includes the GHC version, operating system, word size</li>

<li>also versions of all the packages configured in the project, known
to GHC when compiling a module</li>

<li>cabal also emits a header file describing the environment it has
configured.</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-orga0e822c">
<h2 id="orga0e822c">Why is CPP a problem</h2>
<ul>
<li>It does too much</li>
<li>‚úÖ conditionally include code</li>
<li>‚ùå continuation lines</li>
<li>‚ùå arbitrary text replacement</li>
<li>‚ùå include files</li>

</ul>

<aside class="notes">
<p>
It does or can do too much.
</p>
<ul>
<li>conditionally enable/disable blocks of code</li>
<li>but also
<ul>
<li>combine lines using trailing backslash</li>
<li>process include files</li>
<li>arbitrary replacement of text using #define</li>

</ul></li>
<li>Breaks layering, making code hard(er) to understand</li>

<li>The last items are just an annoyance when trying to understand code,
but make any kind of tooling much more difficult to write</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org60ba2a8">
<h2 id="org60ba2a8">CPP and tooling</h2>
<ul>
<li>Locations</li>
<li>WYS ‚â† WYG</li>
<li>Comments</li>

</ul>

<aside class="notes">
<ul>
<li>The output of the preprocessor is different, by definition
<ul>
<li>So tying things back to original locations gets harder</li>

</ul></li>
<li>Especially with #define, an error message can refer to a location that makes no sense</li>
<li>Tools that want to round trip based on the AST do not see a representation of the original source</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org18ec7e8">
<h2 id="org18ec7e8">üéâ GHC_CPP üéâ</h2>
<ul>
<li>subset implementation of CPP inside GHC</li>
<li>just enough to control conditional compilation</li>
<li>tooling friendly</li>

</ul>

<aside class="notes">
<ul>
<li>Only active in lines introduced with a `#` and preprocessor
keyword.</li>
<li>Tooling friendly, in that parts of the code disabled by the
processor will be saved as comments, if comments are being
processed.</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-orgab721d5">
<h2 id="orgab721d5">GHC Proposal : Ghc CPP #616</h2>

<div id="orgf6cba93" class="figure">
<p><img src="./images-work/ghc-proposal-616.png" alt="ghc-proposal-616.png" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-org01f67c5">
<h2 id="org01f67c5">Goal : managing version changes</h2>
<ul>
<li>Enough power to cover &gt; 90% of current version change usage</li>
<li>Drop-in replacement for the features it <b>does</b> support</li>
<li>Pure, so no include files</li>
<li>Strictly limited scope, only applies in lines starting `#`</li>

</ul>

<aside class="notes">
<p>
Goal is managing unavoidable compatibility issues
</p>

<p>
Haskell has powerful abstraction mechanisms that can cover a lot of
cases, such as patterns
</p>

<p>
But some changes are unavoidable
</p>

<p>
<b>Not</b> intended as a complete replacement. There will always be cases
where it must be used, either for legacy codebases or constrained
environments, such as FFI.
</p>

<p>
Interesting note, the `#` <b>has</b> to start against the margin, else it can
conflict with overloaded record labels
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgd5e49e9">
<h2 id="orgd5e49e9">Implementation</h2>
<div class="outline-text-2" id="text-orgd5e49e9">
</div>
</section>
</section>
<section>
<section id="slide-org0960990">
<h3 id="org0960990">Basis : CPP Spec</h3>
</section>
</section>
<section>
<section id="slide-org2c026f7">
<h3 id="org2c026f7">What features</h3>
<ul>
<li>"bare minimum"</li>
<li>Only process lines starting #, or continuation of one starting #</li>
<li>conditionals:
<ul>
<li>if variants</li>
<li>elif else end</li>

</ul></li>
<li>define, undef</li>
<li>error, currently ignored, could easily emit a diagnostic</li>
<li>No #, ##</li>
<li>No #include, keeps parser/lexer pure.
And not necessary.
<ul>
<li>perhaps stlyised version of machdeps</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org0142bc4">
<h3 id="org0142bc4">Notes</h3>
<ul>
<li>note: two phases: get pragmas, and do parse</li>
<li>preset macros
<ul>
<li>Based on existing CPP pipeline in GHC, but not written to a file
<ul>
<li>GHC version etc</li>
<li>Also based on Unit Env</li>

</ul></li>

</ul></li>
<li>possible optimisation, as used in ghc-exactprint
load pre-processed macros for a project</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgae2b4d1">
<h3 id="orgae2b4d1">Dealing with "off" sections</h3>
<ul>
<li>considered emitting tokens</li>
<li>switched to making it a comment
<ul>
<li>whitespace ALR rule complexity</li>
<li>By definition "off" stuff can be anything
e.g. #if 0, some random chunk of text</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-orgdef61d9">
<h3 id="orgdef61d9">CPP-style comments</h3>
<ul>
<li>can possibly enable them when starting against the left margin, only
<ul>
<li>but prefer to ban them, we have comment syntax</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org069a434">
<h3 id="org069a434">Subset</h3>
<p>
Barest subset of evaluation
</p>
</section>
</section>
<section>
<section id="slide-org2c646a4">
<h3 id="org2c646a4">Usage for ghc-exactprint</h3>
<ul>
<li>skip/ignore unprocessed pragmas</li>
<li>Turn line pragmas into comments
<ul>
<li>means we can trust the lines for relative positioning</li>
<li>implications for use in e.g. HLS</li>
<li>alternative is to use the PsLocs only</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org40652f8">
<h2 id="org40652f8">Usage scenarios</h2>
<ul>
<li>Explicit usage instead of CPP.
<ul>
<li>can be protected by existing CPP, post-process the pragmas, make
GHC_CPP override CPP</li>

</ul></li>
<li>Configured so that the CPP pragma is actually GHC_CPP, for supported compilers</li>
<li>Possible make it ambient enabled, Not sure what the benefit is
But equally, not sure why not</li>
<li>Tooling
<ul>
<li>"in situ", e.g. in HLS where you have a well-configured project, Unit Env
We want line numbers according to line pragmas</li>
<li>"ad hoc", as in ghc-exactprint
Parse only, do not need anything beyond parsing
We do need a reasonable unit env
<ul>
<li>possibly define a "default" macro evaluating to zero</li>

</ul></li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-orgaae3f6e">
<h2 id="orgaae3f6e">Experience report</h2>
<div class="outline-text-2" id="text-orgaae3f6e">
</div>
</section>
<section id="slide-orgeade0a4">
<h4 id="orgeade0a4">roundtrip</h4>
<div class="outline-text-4" id="text-orgeade0a4">
</div>
<ul class="org-ul">
<li><a id="org6aec232"></a>Preparation<br />
<ul>
<li>download all of hackage as at Mar 16</li>
<li>cleanup whitespace, line endings</li>
<li>do a run, patch
<ul>
<li>add missing pragmas
<ul>
<li>from cabal files</li>
<li>for changes in GHC, e.g. NonDecreasingIndent</li>

</ul></li>
<li>minor edits for language changes
<ul>
<li>" @ " -&gt; "@"</li>
<li>"! @ -&gt; "!"</li>

</ul></li>

</ul></li>

</ul>
</li>
<li><a id="org38f0341"></a>fixes<br />
<p>
JavaScriptFFI : allow always
hard-code usage of GHC_CPP
</p>
</li>
</ul>
</section>
<section id="slide-orgd426f9e">
<h4 id="orgd426f9e">actual usage</h4>
<p>
Add a force option?
</p>
</section>
<section id="slide-orgac66f74">
<h4 id="orgac66f74">Results of ghc-exactprint</h4>
<ul>
<li>204,566  of 235k files processed.</li>
<li>Did not have time to sort out pragmas on the remaining 35k odd files</li>
<li>508 could not be processed by GHC_CPP
 32 used #include
385 used #define
 58 CPP-style comments
 21 line concatenation
 12 inadequate context emulation
    MIN_VERSION_xxx
    MIN_TOOL_VERSION_xx</li>

</ul>
</section>
<section id="slide-org68648b4">
<h4 id="org68648b4">caveats</h4>
<ul>
<li>This measures ability to correctly parse a file, and round trip it</li>
<li>does not compare the resulting AST's from CPP and GHC_CPP
<ul>
<li>i.e. does not explicitly check the fidelity of evaluating conditionals</li>
<li>could be done easily enough as we compare original vs ppr versions</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org00be0a1">
<h2 id="org00be0a1">Unused Stuff</h2>
<div class="outline-text-2" id="text-org00be0a1">
</div>
</section>
</section>
<section>
<section id="slide-org8ea5214">
<h3 id="org8ea5214">CPP anti-features</h3>
<ul>
<li>#define</li>
<li>include files</li>
<li>Not aware of GHC comments</li>
<li>Is aware of CPP-style comments</li>
<li>continuation lines</li>

</ul>

<p>
Maybe
</p>
<ul>
<li>line pragmas</li>

</ul>
<p>
But useful for generated code, a definite use-case
HOWEVER, there is a haskell-specific syntax for that already
</p>

<aside class="notes">
<p>
#define that escapes the bounds of CPP directives, that is.
</p>

<p>
These issues are more important from the perspective of tool writers
#define: darcs has a file gadts.h defining stuff for use with and without them
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org5a2e1a8">
<h3 id="org5a2e1a8">Why</h3>
<ul>
<li>tooling</li>

</ul>

<aside class="notes">
<p>
I look after ghc-exactprint, a library to allow changes to the GHC
parsed ast, and print it back to source.
This is difficult or impossible with the current preprocessor
implementation.
</p>

</aside>
</section>
<section id="slide-org4559a1b">
<h4 id="org4559a1b">tooling</h4>
<div class="outline-text-4" id="text-org4559a1b">
</div>
<ul class="org-ul">
<li><a id="orga3ce359"></a>ghc-exactprint<br />
<ul>
<li>Difficult to manage the pieces, especially the anti-features</li>

</ul>
</li>
<li><a id="org0b75378"></a>retrie<br />
<p>
Works with all expansions of CPP options for a file
</p>
</li>
<li><a id="org97a485f"></a>ormolu<br />
<p>
Need to check what it does
<a href="https://github.com/tweag/ormolu/blob/master/DESIGN.md#cpp">https://github.com/tweag/ormolu/blob/master/DESIGN.md#cpp</a>
</p>

<blockquote>
<p>
If CPP is replaced with some language extension or mechanism to do
conditional compilation, all tools will benefit from it.
</p>
</blockquote>
</li>
</ul>
</section>
<section id="slide-org6a71eb7">
<h4 id="org6a71eb7">tooling recap</h4>
<p>
Every tool is doing its own best to cope with it
</p>
</section>
<section id="slide-orgf62a61e">
<h4 id="orgf62a61e">simplification</h4>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>
<script src="./reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: false,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
totalTime: 1200,
overview: true,

transition: 'linear',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
