<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>An alternative to CPP (HIW 2025)</title>
<meta name="author" content="Alan Zimmerman"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/white_contrast_compact_verbatim_headers.css" id="theme"/>

<link rel="stylesheet" href="./local.css"/>

<link rel="stylesheet" href="./reveal.js/plugin/toc-progress/toc-progress.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<section id="slide-org440839a">
<h2 id="org440839a">An alternative to CPP</h2>
<p>
Alan Zimmerman
</p>

<p>
<a href="https://social.coop/@alanz"><code>@alanz@social.coop</code></a>
</p>

<p>
Haskell Implementors' Workshop,
</p>

<p>
ZuriHac, 2025-06-06
</p>

<aside class="notes">
<p>
Hi, Alan Zimmerman, I look after ghc-exactprint.
</p>

<p>
And today I want to talk about CPP, which has pained me ever since I
started working on Haskell refactoring tools over ten years ago.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgb9a25f7">
<h2 id="orgb9a25f7">CPP</h2>
<ul>
<li>In use from the beginning, at least GHC 2.0</li>
<li>Used mainly to manage differences between versions</li>
<li>Is outside the language of Haskell</li>

</ul>

<aside class="notes">
<p>
The C preprocessor. Or C++ preprocessor.
</p>

<p>
My 5 min research shows it was in GHC 2 already, from 1997.
<a href="https://downloads.haskell.org/~ghc/old_docs/2.10/users_guide/user_33.html#IDX109">https://downloads.haskell.org/~ghc/old_docs/2.10/users_guide/user_33.html#IDX109</a>
The docs are for 2.10, but the changelog back to 2.0 does not mention it being added.
</p>

<p>
Because it is outside the language, it can manage changes between
versions without itself being tripped up by syntax.
</p>

<p>
It runs using the generalised GHC capability to run a preprocessor
programme over the source
</p>

<p>
But is in a privileged position because it is deeply embedded in GHC
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgf08911e">
<h2 id="orgf08911e">CPP Support in GHC</h2>
<ul>
<li>CPP is an extension, which triggers all the machinery
<ul>
<li>See <a href="https://github.com/ghc/ghc/blob/b255a8ca815920f5219dd5136bbb505f684b7e26/compiler/GHC/SysTools/Cpp.hs#L49">Note [Preprocessing invocations]‚Äã</a></li>

</ul></li>
<li>GHC provides predefined macros describing the environment
<ul>
<li>Includes the <a href="https://github.com/ghc/ghc/blob/b255a8ca815920f5219dd5136bbb505f684b7e26/compiler/GHC/SysTools/Cpp.hs#L139">GHC version, operating system, word size</a></li>
<li>also versions of <a href="https://github.com/ghc/ghc/blob/b255a8ca815920f5219dd5136bbb505f684b7e26/compiler/GHC/SysTools/Cpp.hs#L183">all the packages configured in the project</a>, known
to GHC when compiling a module</li>
<li>cabal also <a href="https://github.com/ghc/packages-Cabal/blob/6f22f2a789fa23edb210a2591d74ea6a5f767872/Cabal/Distribution/Simple/Build.hs#L698">emits a header file</a> describing the environment it has
configured.</li>

</ul></li>
<li>Even so, it is invoked as an external programme</li>

</ul>
</section>
</section>
<section>
<section id="slide-org94c59a8">
<h2 id="org94c59a8">Why is CPP a problem</h2>
<ul>
<li>It does too much:
<ul>
<li>‚úÖ conditionally select code</li>
<li>‚ùå continuation lines</li>
<li>‚ùå arbitrary text replacement</li>
<li>‚ùå include files</li>

</ul></li>

</ul>

<aside class="notes">
<p>
It does or can do too much.
</p>
<ul>
<li>conditionally enable/disable blocks of code</li>
<li>but also
<ul>
<li>combine lines using trailing backslash</li>
<li>process include files</li>
<li>arbitrary replacement of text using #define</li>

</ul></li>
<li>Breaks layering, making code hard(er) to understand</li>

<li>The last items are just an annoyance when trying to understand code,
but make any kind of tooling much more difficult to write</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-orgc120edc">
<h2 id="orgc120edc">CPP and tooling</h2>
<ul>
<li>Locations</li>
<li>WYS ‚â† WYG</li>
<li>Comments</li>

</ul>

<aside class="notes">
<ul>
<li>This is my main beef</li>
<li>The output of the preprocessor is different, by definition
<ul>
<li>So tying things back to original locations gets harder</li>

</ul></li>
<li>Especially with #define, an error message can refer to a location that makes no sense
But it is sometimes useful, e.g. darcs has "gadts.h" defining macros for key types
CHECK</li>
<li>Comments are stripped, and / or mangled
e.g. commented out CPP macros disappear</li>
<li>Tools that want to round trip based on the AST do not see a
representation of the original source</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org7092a14">
<h2 id="org7092a14">üéâ GHC_CPP üéâ</h2>
<ul>
<li>subset implementation of CPP inside GHC</li>
<li>just enough to control conditional compilation</li>
<li>tooling friendly</li>

</ul>

<aside class="notes">
<ul>
<li>Idea</li>
<li>Only active in lines introduced with a `#` and preprocessor
keyword.</li>
<li>Tooling friendly, in that parts of the code disabled by the
processor will be saved as comments, if comments are being
processed.</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-orgfd5cd81">
<h2 id="orgfd5cd81">GHC Proposal : Ghc CPP #616</h2>

<div id="org6ce9868" class="figure">
<p><img src="./images-work/ghc-proposal-616.png" alt="ghc-proposal-616.png" />
</p>
</div>

<aside class="notes">
<p>
I was looking at my HEW talk from last year, and see I was pushing it
then already.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org4c3dc28">
<h2 id="org4c3dc28">Goal : managing version changes</h2>
<ul>
<li>Enough power to cover &gt; 90% of current version change usage</li>
<li>Drop-in replacement for the features it <b>does</b> support</li>
<li>Pure, so no include files</li>
<li>Strictly limited scope, only applies in lines starting `#`</li>

</ul>

<aside class="notes">
<p>
Goal is managing unavoidable compatibility issues
</p>

<p>
Haskell has powerful abstraction mechanisms that can cover a lot of
cases, such as patterns
</p>

<p>
But some changes are unavoidable
</p>

<p>
<b>Not</b> intended as a complete replacement. There will always be cases
where it must be used, either for legacy codebases or constrained
environments, such as FFI.
</p>

<p>
Interesting note, the `#` <b>has</b> to start against the margin, else it can
conflict with overloaded record labels
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org13e7ef8">
<h2 id="org13e7ef8">Implementation : Big picture</h2>
<ul>
<li>Modify lexer to include tokens for preprocessor directives</li>
<li>Add a preprocessing step between the lexer and parser</li>
<li>Profit</li>

</ul>
<aside class="notes">
<ul>
<li>Tokens starting # and a keyword, and their continuations</li>
<li>Also provide a cppignore token, which is basically a kind of comment</li>
<li>Preprocessing step accumulates a full directive, and processes it,
if extension enabled
<ul>
<li>Otherwise a straight pass-through</li>
<li>Unless we are in a cpp disabled zone, where the contents are
passed as cppignore tokens, one per line</li>
<li>I Considered passing actual tokens, but
<ul>
<li>there is no guarantee it will be valid haskell</li>
<li>managing layout state makes it complex</li>

</ul></li>

</ul></li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org7f79d10">
<h2 id="org7f79d10">Basis : CPP Spec</h2>
<p>
I worked from an <a href="https://timsong-cpp.github.io/cppwp/n4140">online version</a> at
<a href="https://timsong-cpp.github.io/cppwp/n4140/">https://timsong-cpp.github.io/cppwp/n4140/</a>
</p>

<aside class="notes">
<p>
Processing pipeline for directives only includes
</p>
<ul>
<li>tokenisation and line combination, comment removal, flatten repeated
spaces, add a space between each</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org35c64f8">
<h2 id="org35c64f8">What features</h2>
<ul>
<li>"bare minimum"</li>
<li>Only process lines starting #, or continuation of one starting #</li>
<li>conditionals:
<ul>
<li>if variants</li>
<li>elif else end</li>

</ul></li>
<li>define, undef</li>
<li>error, currently ignored, could easily emit a diagnostic</li>
<li>No #, ##</li>
<li>No #include, keeps parser/lexer pure.
And not necessary.
<ul>
<li>perhaps stlyised version of machdeps</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org8ae829f">
<h2 id="org8ae829f">Usage scenario 1 : CPP alternative</h2>
<ul>
<li>Explicit usage instead of CPP</li>

</ul>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4169e1;">{-# LANGUAGE CPP #-}</span>
<span style="color: #483d8b;">#if __GLASGOW_HASKELL__ &gt;= VERSION_WITH_GHCCPP</span>
<span style="color: #4169e1;">{-# LANGUAGE GHC_CPP #-}</span>
<span style="color: #483d8b;">#endif</span>
</pre>
</div>
<ul>
<li>Configured so that the CPP pragma is actually GHC_CPP, for supported
compilers</li>

<li>Possible make it ambient enabled</li>

</ul>

<aside class="notes">
<p>
The usage "normal" developers see
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgd0178f8">
<h2 id="orgd0178f8">Complication: Line pragmas</h2>
<ul>
<li>GHC Lexer.x already processes these natively</li>
<li>Tooling Problem
<ul>
<li>Swallows the original</li>
<li>Location changes</li>

</ul></li>

</ul>

<aside class="notes">
<ul>
<li>The intent is that the location changes, but that makes exact printing unreliable</li>
<li>Maybe use the PsSpan instead and allow changes</li>
<li>Currently in GHC_CPP mode these become comments instead</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org1063048">
<h2 id="org1063048">Usage scenario 2 : Code modification</h2>
<ul>
<li>skip/ignore unprocessed pragmas</li>
<li>Turn line pragmas into comments
<ul>
<li>means we can trust the lines for relative positioning</li>

</ul></li>

</ul>

<aside class="notes">
<p>
My primary motivation
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgc3b7424">
<h2 id="orgc3b7424">Experience report : hackage roundtrip</h2>
<ul>
<li>download all of hackage as at Mar 16</li>
<li>cleanup whitespace, line endings</li>
<li>do a run, patch
<ul>
<li>add missing pragmas
<ul>
<li>from cabal files</li>
<li>for changes in GHC, e.g. <code class="src src-haskell"><span style="color: #228b22;">NonDecreasingIndent</span></code></li>

</ul></li>
<li>minor edits for language changes
<ul>
<li>" @ " -&gt; "@"</li>
<li>"! @ -&gt; "!"</li>

</ul></li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org0fc7c38">
<h2 id="org0fc7c38">ghc-exactprint tweaks</h2>
<ul>
<li>always allow <code class="src src-haskell"><span style="color: #228b22;">JavaScriptFFI</span></code></li>
<li>hard-code usage of GHC_CPP</li>
<li>preset unit env macros to all of hackage</li>

</ul>
</section>
</section>
<section>
<section id="slide-org34ebadf">
<h2 id="org34ebadf">Results of ghc-exactprint</h2>
<ul>
<li>204,566  files processed.</li>
<li>508 could not be processed by GHC_CPP (0.25%)
 32 used #include
385 used #define
 58 CPP-style comments
 21 line concatenation
 12 inadequate context emulation
    MIN_VERSION_xxx
    MIN_TOOL_VERSION_xx</li>

</ul>

<aside class="notes">
<ul>
<li>Total hackage download is 235k files, did not have time to scrub the last ones</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org3e50d29">
<h2 id="org3e50d29">caveats</h2>
<ul>
<li>This measures ability to correctly parse a file, and round trip it</li>
<li>does not compare the resulting AST's from CPP and GHC_CPP
<ul>
<li>i.e. does not explicitly check the fidelity of evaluating
conditionals</li>
<li>could be done easily enough as we compare original vs ppr versions</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org6bde550">
<h2 id="org6bde550">End</h2>
<p>
This presentation: <a href="https://alanz.github.io/h1w2025/">https://alanz.github.io/h1w2025/</a>
<img src="./images-work/hiw2025-url.png" alt="hiw2025-url.png" />
</p>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/pull/616">GHC CPP proposal</a></li>
<li>GHC feature branch: <a href="https://gitlab.haskell.org/ghc/ghc/-/tree/wip/az/ghc-cpp">https://gitlab.haskell.org/ghc/ghc/-/tree/wip/az/ghc-cpp</a></li>
<li>Matching ghc-exactprint: <a href="https://github.com/alanz/ghc-exactprint/tree/ghc_cpp">https://github.com/alanz/ghc-exactprint/tree/ghc_cpp</a></li>

<li>Slides written in emacs <a href="https://orgmode.org/">org-mode</a> using <a href="https://gitlab.com/oer/org-re-reveal">org-re-reveal</a> for <a href="https://revealjs.com/">reveal.js</a></li>

</ul>

<p>
Questions?
</p>
</section>
</section>
<section>
<section id="slide-orga221dc7">
<h2 id="orga221dc7">Unused Stuff</h2>
<div class="outline-text-2" id="text-orga221dc7">
</div>
</section>
</section>
<section>
<section id="slide-org44a3a80">
<h3 id="org44a3a80">CPP anti-features</h3>
<ul>
<li>#define</li>
<li>include files</li>
<li>Not aware of GHC comments</li>
<li>Is aware of CPP-style comments</li>
<li>continuation lines</li>

</ul>

<p>
Maybe
</p>
<ul>
<li>line pragmas</li>

</ul>
<p>
But useful for generated code, a definite use-case
HOWEVER, there is a haskell-specific syntax for that already
</p>

<aside class="notes">
<p>
#define that escapes the bounds of CPP directives, that is.
</p>

<p>
These issues are more important from the perspective of tool writers
#define: darcs has a file gadts.h defining stuff for use with and without them
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orge835b86">
<h3 id="orge835b86">Why</h3>
<ul>
<li>tooling</li>

</ul>

<aside class="notes">
<p>
I look after ghc-exactprint, a library to allow changes to the GHC
parsed ast, and print it back to source.
This is difficult or impossible with the current preprocessor
implementation.
</p>

</aside>
</section>
<section id="slide-orgdabb276">
<h4 id="orgdabb276">tooling</h4>
<div class="outline-text-4" id="text-orgdabb276">
</div>
<ul class="org-ul">
<li><a id="org25fce9b"></a>ghc-exactprint<br />
<ul>
<li>Difficult to manage the pieces, especially the anti-features</li>

</ul>
</li>
<li><a id="orgced4088"></a>retrie<br />
<p>
Works with all expansions of CPP options for a file
</p>
</li>
<li><a id="orgdcb693b"></a>ormolu<br />
<p>
Need to check what it does
<a href="https://github.com/tweag/ormolu/blob/master/DESIGN.md#cpp">https://github.com/tweag/ormolu/blob/master/DESIGN.md#cpp</a>
</p>

<blockquote>
<p>
If CPP is replaced with some language extension or mechanism to do
conditional compilation, all tools will benefit from it.
</p>
</blockquote>
</li>
</ul>
</section>
<section id="slide-org938cee4">
<h4 id="org938cee4">tooling recap</h4>
<p>
Every tool is doing its own best to cope with it
</p>
</section>
<section id="slide-org3847fbb">
<h4 id="org3847fbb">simplification</h4>
</section>
</section>
<section>
<section id="slide-orgb48ca8c">
<h3 id="orgb48ca8c">Notes</h3>
<ul>
<li>note: two phases: get pragmas, and do parse</li>
<li>preset macros
<ul>
<li>Based on existing CPP pipeline in GHC, but not written to a file
<ul>
<li>GHC version etc</li>
<li>Also based on Unit Env</li>

</ul></li>

</ul></li>
<li>possible optimisation, as used in ghc-exactprint
load pre-processed macros for a project</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgb023a53">
<h3 id="orgb023a53">Dealing with "off" sections</h3>
<ul>
<li>considered emitting tokens</li>
<li>switched to making it a comment
<ul>
<li>whitespace ALR rule complexity</li>
<li>By definition "off" stuff can be anything
e.g. #if 0, some random chunk of text</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org8555be1">
<h3 id="org8555be1">CPP-style comments</h3>
<ul>
<li>can possibly enable them when starting against the left margin, only
<ul>
<li>but prefer to ban them, we have comment syntax</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-orge71bbb5">
<h3 id="orge71bbb5">Subset</h3>
<p>
Barest subset of evaluation
</p>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>
<script src="./reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: false,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
totalTime: 1200,
overview: true,

transition: 'linear',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
