<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>An alternative to CPP (HIW 2025)</title>
<meta name="author" content="Alan Zimmerman"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/white_contrast_compact_verbatim_headers.css" id="theme"/>

<link rel="stylesheet" href="./local.css"/>

<link rel="stylesheet" href="./reveal.js/plugin/toc-progress/toc-progress.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<section id="slide-org621497a">
<h2 id="org621497a">An alternative to CPP</h2>
<p>
Alan Zimmerman
</p>

<p>
<a href="https://social.coop/@alanz"><code>@alanz@social.coop</code></a>
</p>

<p>
Haskell Implementors' Workshop,
</p>

<p>
ZuriHac, 2025-06-06
</p>
</section>
</section>
<section>
<section id="slide-orgb5eaca0">
<h2 id="orgb5eaca0">CPP</h2>
<ul>
<li>In use from the beginning, at least GHC 2.0
<ul>
<li>Used mainly to manage differences between versions</li>
<li>Is outside of the language, so independent of it, and can do the
job</li>
<li>But all features in an API will be used</li>

</ul></li>

</ul>

<aside class="notes">
<p>
My 5 min research shows it was in GHC 2 already, from 1997.
<a href="https://downloads.haskell.org/~ghc/old_docs/2.10/users_guide/user_33.html#IDX109">https://downloads.haskell.org/~ghc/old_docs/2.10/users_guide/user_33.html#IDX109</a>
The docs are for 2.10, but the changelog back to 2.0 does not mention it being added.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org57dea7b">
<h2 id="org57dea7b">CPP anti-features</h2>
<ul>
<li>#define</li>
<li>include files</li>
<li>Not aware of GHC comments</li>
<li>Is aware of CPP-style comments</li>
<li>continuation lines</li>

</ul>

<p>
Maybe
</p>
<ul>
<li>line pragmas</li>

</ul>
<p>
But useful for generated code, a definite use-case
HOWEVER, there is a haskell-specific syntax for that already
</p>

<aside class="notes">
<p>
These issues are more important from the perspective of tool writers
#define: darcs has a file gadts.h defining stuff for use with and without them
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org45987e2">
<h2 id="org45987e2">Motivation</h2>
<div class="outline-text-2" id="text-org45987e2">
</div>
</section>
</section>
<section>
<section id="slide-orgf250748">
<h3 id="orgf250748">What</h3>
<ul>
<li>subset implementation of CPP inside GHC</li>

</ul>
</section>
</section>
<section>
<section id="slide-org4f0a778">
<h3 id="org4f0a778">Why</h3>
<div class="outline-text-3" id="text-org4f0a778">
</div>
</section>
<section id="slide-org5b8f18e">
<h4 id="org5b8f18e">tooling</h4>
<div class="outline-text-4" id="text-org5b8f18e">
</div>
<ul class="org-ul">
<li><a id="org023e890"></a>ghc-exactprint<br />
<ul>
<li>Difficult to manage the pieces, especially the anti-features</li>

</ul>
</li>
<li><a id="org489dbd7"></a>retrie<br />
<p>
Works with all expansions of CPP options for a file
</p>
</li>
<li><a id="org52e4a79"></a>ormolu<br />
<p>
Need to check what it does
<a href="https://github.com/tweag/ormolu/blob/master/DESIGN.md#cpp">https://github.com/tweag/ormolu/blob/master/DESIGN.md#cpp</a>
</p>

<blockquote>
<p>
If CPP is replaced with some language extension or mechanism to do
conditional compilation, all tools will benefit from it.
</p>
</blockquote>
</li>
</ul>
</section>
<section id="slide-org3adc339">
<h4 id="org3adc339">tooling recap</h4>
<p>
Every tool is doing its own best to cope with it
</p>
</section>
<section id="slide-org68eb67c">
<h4 id="org68eb67c">simplification</h4>
</section>
</section>
<section>
<section id="slide-org92c6ace">
<h3 id="org92c6ace">Goals</h3>
<div class="outline-text-3" id="text-org92c6ace">
</div>
</section>
<section id="slide-orgad0b658">
<h4 id="orgad0b658">Limited subset</h4>
<p>
Chosen how?
Lets look at some empirical results
</p>
</section>
</section>
<section>
<section id="slide-orgd8e5d4e">
<h2 id="orgd8e5d4e">Implementation</h2>
<div class="outline-text-2" id="text-orgd8e5d4e">
</div>
</section>
</section>
<section>
<section id="slide-org49f385b">
<h3 id="org49f385b">Basis : CPP Spec</h3>
</section>
</section>
<section>
<section id="slide-orgc92d0e9">
<h3 id="orgc92d0e9">What features</h3>
<ul>
<li>"bare minimum"</li>
<li>Only process lines starting #, or continuation of one starting #</li>
<li>conditionals:
<ul>
<li>if variants</li>
<li>elif else end</li>

</ul></li>
<li>define, undef</li>
<li>error, currently ignored, could easily emit a diagnostic</li>
<li>No #, ##</li>
<li>No #include, keeps parser/lexer pure.
And not necessary.
<ul>
<li>perhaps stlyised version of machdeps</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org7384738">
<h3 id="org7384738">Notes</h3>
<ul>
<li>note: two phases: get pragmas, and do parse</li>
<li>preset macros
<ul>
<li>Based on existing CPP pipeline in GHC, but not written to a file
<ul>
<li>GHC version etc</li>
<li>Also based on Unit Env</li>

</ul></li>

</ul></li>
<li>possible optimisation, as used in ghc-exactprint
load pre-processed macros for a project</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgdbf9f23">
<h3 id="orgdbf9f23">Dealing with "off" sections</h3>
<ul>
<li>considered emitting tokens</li>
<li>switched to making it a comment
<ul>
<li>whitespace ALR rule complexity</li>
<li>By definition "off" stuff can be anything
e.g. #if 0, some random chunk of text</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org641a9f3">
<h3 id="org641a9f3">CPP-style comments</h3>
<ul>
<li>can possibly enable them when starting against the left margin, only
<ul>
<li>but prefer to ban them, we have comment syntax</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org09c0b65">
<h3 id="org09c0b65">Subset</h3>
<p>
Barest subset of evaluation
</p>
</section>
</section>
<section>
<section id="slide-org8ce9904">
<h3 id="org8ce9904">Usage for ghc-exactprint</h3>
<ul>
<li>skip/ignore unprocessed pragmas</li>
<li>Turn line pragmas into comments
<ul>
<li>means we can trust the lines for relative positioning</li>
<li>implications for use in e.g. HLS</li>
<li>alternative is to use the PsLocs only</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org511c45b">
<h2 id="org511c45b">Usage scenarios</h2>
<ul>
<li>Explicit usage instead of CPP.
<ul>
<li>can be protected by existing CPP, post-process the pragmas, make
GHC<sub>CPP</sub> override CPP</li>

</ul></li>
<li>Configured so that the CPP pragma is actually GHC<sub>CPP</sub>, for supported compilers</li>
<li>Possible make it ambient enabled, Not sure what the benefit is
But equally, not sure why not</li>
<li>Tooling
<ul>
<li>"in situ", e.g. in HLS where you have a well-configured project, Unit Env
We want line numbers according to line pragmas</li>
<li>"ad hoc", as in ghc-exactprint
Parse only, do not need anything beyond parsing
We do need a reasonable unit env
<ul>
<li>possibly define a "default" macro evaluating to zero</li>

</ul></li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org9c79083">
<h2 id="org9c79083">Experience report</h2>
<div class="outline-text-2" id="text-org9c79083">
</div>
</section>
<section id="slide-orgca92710">
<h4 id="orgca92710">roundtrip</h4>
<div class="outline-text-4" id="text-orgca92710">
</div>
<ul class="org-ul">
<li><a id="org70a795d"></a>Preparation<br />
<ul>
<li>download all of hackage as at Mar 16</li>
<li>cleanup whitespace, line endings</li>
<li>do a run, patch
<ul>
<li>add missing pragmas
<ul>
<li>from cabal files</li>
<li>for changes in GHC, e.g. NonDecreasingIndent</li>

</ul></li>
<li>minor edits for language changes
<ul>
<li>" @ " -&gt; "@"</li>
<li>"! @ -&gt; "!"</li>

</ul></li>

</ul></li>

</ul>
</li>
<li><a id="orge85a1d3"></a>fixes<br />
<p>
JavaScriptFFI : allow always
hard-code usage of GHC<sub>CPP</sub>
</p>
</li>
</ul>
</section>
<section id="slide-orgc62edde">
<h4 id="orgc62edde">actual usage</h4>
<p>
Add a force option?
</p>
</section>
<section id="slide-orgb9a56cc">
<h4 id="orgb9a56cc">Results of ghc-exactprint</h4>
<ul>
<li>204,566  of 235k files processed.</li>
<li>Did not have time to sort out pragmas on the remaining 35k odd files</li>
<li>508 could not be processed by GHC<sub>CPP</sub>
 32 used #include
385 used #define
 58 CPP-style comments
 21 line concatenation
 12 inadequate context emulation
    MIN<sub>VERSION</sub><sub>xxx</sub>
    MIN<sub>TOOL</sub><sub>VERSION</sub><sub>xx</sub></li>

</ul>
</section>
<section id="slide-orgf125f98">
<h4 id="orgf125f98">caveats</h4>
<ul>
<li>This measures ability to correctly parse a file, and round trip it</li>
<li>does not compare the resulting AST's from CPP and GHC<sub>CPP</sub>
<ul>
<li>i.e. does not explicitly check the fidelity of evaluating conditionals</li>
<li>could be done easily enough as we compare original vs ppr versions</li>

</ul></li>

</ul>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>
<script src="./reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: false,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
totalTime: 1200,
overview: true,

transition: 'linear',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
